package com.vcompany.restaurant.api.controller.handler;

import com.vcompany.restaurant.api.model.Error;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.TypeMismatchException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import javax.validation.ConstraintViolationException;

/**
 * This controller advice handles exceptions generated by the API.
 */
@ControllerAdvice
public class DefaultExceptionHandler extends ResponseEntityExceptionHandler {

    private final Logger log = LoggerFactory.getLogger(getClass());

    @Override
    protected ResponseEntity<Object> handleExceptionInternal(Exception ex, Object body, HttpHeaders headers, HttpStatus status, WebRequest request) {
        log.error("Handling exception internal", ex);

        return ResponseEntity.status( 500 ).body( createError( ex, status) );
    }

    @Override
    protected ResponseEntity<Object> handleTypeMismatch(TypeMismatchException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {
        log.error("Handling type mismatch exception", ex);

        return ResponseEntity.badRequest().body( createError( ex, status) );
    }

    /**
     * It handles constraint violation exception and generates and error as defined by API Contract.
     *
     * @param ex the constraint violation exception handled.
     * @param request the webRequest that originated the exception
     * @return the error model generated from the exception.
     */
    @ExceptionHandler(value = {ConstraintViolationException.class})
    protected ResponseEntity<Error> handleConstraintViolationException(final ConstraintViolationException ex, final WebRequest request) {
        log.error("Handling constraint violation exception", ex);

        return ResponseEntity.badRequest().body( createError( ex, 400 ));
    }

    /**
     * It creates and error model based on and exception and http status.
     *
     * @param exception the exception which contains the error message.
     * @param status the http status which contains the error code.
     *
     * @return the error model created.
     */
    private Error createError(Exception exception, HttpStatus status ){
        return createError(exception, status.value());
    }

    /**
     * It creates and error model based on and exception and an error code.
     *
     * @param exception the exception which contains the error message.
     * @param code the error code.
     *
     * @return the error model created.
     */
    private Error createError(Exception exception, Integer code ){
        String description = exception.getMessage();

        log.debug("Creating an error based on the following information: code {} and description {}...", code, description );

        Error error = new Error().code(code).description(description);
        return error;
    }
}
